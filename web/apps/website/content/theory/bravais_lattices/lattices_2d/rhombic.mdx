import { 
    LatticeVisualization2D, 
    ReciprocalLatticeVisualization2D, 
    WignerSeitzCell2D,
    HighSymmetryVisualization2D,
} from '../../../../src/components';

import { Callout, Tabs } from 'nextra/components';

# Rhombic Lattice (Centered Rectangular)

The **rhombic lattice** (also known as the centered rectangular lattice) is one of the five fundamental two-dimensional Bravais lattices, characterized by its centered unit cell and diamond-like symmetry. This lattice type appears in many crystallographic systems and represents an important bridge between rectangular and oblique lattice structures.

## Quick Reference

### Basic Properties

| Property | Value |
|----------|-------|
| **Lattice System** | Centered Rectangular |
| **Point Group** | 2mm |
| **Coordination Number** | 4 |
| **Primitive Vectors** | Rhombic arrangement |
| **Unit Cell Area** | $ab$ (conventional), $\frac{ab}{2}$ (primitive) |
| **Lattice Type** | Centered (C) |
| **Packing Density** | $\frac{\pi}{2\sqrt{3}} \approx 0.907$ |

### High-Symmetry Points

| Point | Position | Description |
|-------|----------|-------------|
| **Γ** | $(0, 0)$ | Zone center |
| **X** | $(\frac{\pi}{a}, 0)$ | BZ boundary (a-direction) |
| **Y** | $(0, \frac{\pi}{b})$ | BZ boundary (b-direction) |
| **M** | $(\frac{\pi}{a}, \frac{\pi}{b})$ | Zone corner |

## Visual Representation

### Real Space Lattice

<LatticeVisualization2D
    latticeType="centered_rectangular"
    a={1}
    b={0.8}
    shells={2}
    showUnitCell={true}
    showLatticeVectors={true}
/>

**Figure 1:** Rhombic lattice in real space showing lattice points (blue dots), primitive vectors **a₁** and **a₂** (arrows), and the primitive unit cell (dashed parallelogram). The lattice exhibits centered rectangular symmetry with additional lattice points at cell centers.

### Reciprocal Space Lattice

<LatticeVisualization2D
    latticeType="centered_rectangular"
    a={1}
    b={0.8}
    shells={1}
    showUnitCell={true}
    showLatticeVectors={true}
    is_reciprocal={true}
/>

**Figure 2:** Rhombic reciprocal lattice showing reciprocal lattice points, primitive vectors **b₁** and **b₂**, and the first Brillouin zone (dashed parallelogram). The reciprocal lattice transforms the centered rectangular arrangement into a rhombic structure.

### Brillouin Zone and High-Symmetry Points

<HighSymmetryVisualization2D
    latticeType="centered_rectangular"
    a={1}
    b={0.8}
    shells={1}
    showUnitCell={true}
/>

**Figure 3:** First Brillouin zone of the rhombic lattice showing high-symmetry points and paths. The Brillouin zone exhibits the characteristic rhombic shape resulting from the centered rectangular lattice structure.

## Mathematical Description

### Real Space

The rhombic lattice can be described using a centered rectangular unit cell with conventional lattice parameters $a$ and $b$, or using primitive vectors that form a rhombus. The primitive vectors are:

$$\mathbf{a}_1 = \frac{a}{2}\hat{\mathbf{x}} + \frac{b}{2}\hat{\mathbf{y}}, \quad \mathbf{a}_2 = \frac{a}{2}\hat{\mathbf{x}} - \frac{b}{2}\hat{\mathbf{y}}$$

where the vectors satisfy:

$$|\mathbf{a}_1| = |\mathbf{a}_2| = \frac{\sqrt{a^2 + b^2}}{2}, \quad \mathbf{a}_1 \cdot \mathbf{a}_2 = \frac{a^2 - b^2}{4}$$

The angle between the primitive vectors is:

$$\cos\theta = \frac{\mathbf{a}_1 \cdot \mathbf{a}_2}{|\mathbf{a}_1||\mathbf{a}_2|} = \frac{a^2 - b^2}{a^2 + b^2}$$

The primitive unit cell area is:

$$A = |\mathbf{a}_1 \times \mathbf{a}_2| = \frac{ab}{2}$$

### Reciprocal Space

The reciprocal lattice vectors $\mathbf{b}_1$ and $\mathbf{b}_2$ satisfy $\mathbf{a}_i \cdot \mathbf{b}_j = 2\pi \delta_{ij}$:

$$\mathbf{b}_1 = \frac{2\pi}{a}\hat{\mathbf{x}} + \frac{2\pi}{b}\hat{\mathbf{y}}, \quad \mathbf{b}_2 = \frac{2\pi}{a}\hat{\mathbf{x}} - \frac{2\pi}{b}\hat{\mathbf{y}}$$

The reciprocal lattice primitive cell area is:

$$A^* = |\mathbf{b}_1 \times \mathbf{b}_2| = \frac{8\pi^2}{ab}$$

## Real vs Reciprocal Space Comparison

| Property | Real Space | Reciprocal Space |
|----------|------------|------------------|
| **Lattice Type** | Centered Rectangular | Rhombic |
| **Primitive Vectors** | Rhombic arrangement | Rhombic arrangement |
| **Unit Cell Shape** | Rhombus | Rhombus |
| **Unit Cell Area** | $\frac{ab}{2}$ | $\frac{8\pi^2}{ab}$ |
| **Symmetry** | 2-fold rotational | 2-fold rotational |
| **Coordination** | 4 nearest neighbors | 4 nearest neighbors |
| **Angle** | $\cos^{-1}\left(\frac{a^2-b^2}{a^2+b^2}\right)$ | $\cos^{-1}\left(\frac{b^2-a^2}{a^2+b^2}\right)$ |

## Lattice Data Reference

Essential lattice parameters and coordinates for rhombic lattice calculations:

<Tabs items={['Python', 'Rust', 'C++']}>
  <Tabs.Tab>
    ```python
    import numpy as np
    from math import sqrt, pi, acos, degrees
    
    # Lattice parameters (user-defined)
    a = 1.0  # conventional lattice constant along x
    b = 0.8  # conventional lattice constant along y
    
    # ===== REAL SPACE LATTICE =====
    
    # Primitive basis vectors (rhombic arrangement)
    a1 = np.array([a/2, b/2])
    a2 = np.array([a/2, -b/2])
    
    # Real space unit cell area (primitive)
    real_cell_area = abs(np.cross(a1, a2))  # = ab/2
    
    # Conventional unit cell area
    conventional_cell_area = a * b
    
    # Lattice vector properties
    a1_length = np.linalg.norm(a1)  # sqrt(a²+b²)/2
    a2_length = np.linalg.norm(a2)  # sqrt(a²+b²)/2
    dot_product = np.dot(a1, a2)    # (a²-b²)/4
    angle_rad = acos(dot_product / (a1_length * a2_length))
    angle_deg = degrees(angle_rad)
    
    # ===== RECIPROCAL SPACE LATTICE =====
    
    # Reciprocal basis vectors
    b1 = (2*pi/a) * np.array([1.0, 1.0])
    b2 = (2*pi/a) * np.array([1.0, -1.0])
    
    # Alternative calculation using cross product formula
    # For 2D: b1 = 2π * (a2_perp) / |a1 × a2|
    a1_perp = np.array([a2[1], -a2[0]])  # Perpendicular to a2
    a2_perp = np.array([-a1[1], a1[0]])  # Perpendicular to a1
    
    b1_alt = 2*pi * a1_perp / real_cell_area
    b2_alt = 2*pi * a2_perp / real_cell_area
    
    # Brillouin zone area
    bz_area = abs(np.cross(b1, b2))  # = 8π²/(ab)
    
    # ===== HIGH SYMMETRY POINTS =====
    
    # Fractional coordinates (in units of reciprocal lattice vectors)
    gamma_frac = np.array([0.0, 0.0])
    x_frac = np.array([0.5, 0.0])
    y_frac = np.array([0.0, 0.5])
    m_frac = np.array([0.5, 0.5])
    
    # Cartesian coordinates
    gamma_cart = np.array([0.0, 0.0])
    x_cart = 0.5 * b1  # = (π/a, π/a)
    y_cart = 0.5 * b2  # = (π/a, -π/a)
    m_cart = 0.5 * (b1 + b2)  # = (π/a, 0)
    
    # ===== BRILLOUIN ZONE VERTICES =====
    
    # First BZ vertices (rhombus corners)
    bz_vertices = np.array([
        0.5 * (b1 + b2),   # M point
        0.5 * (b1 - b2),   # 
        -0.5 * (b1 + b2),  # -M point
        0.5 * (-b1 + b2)   # 
    ])
    
    # ===== DISTANCES =====
    
    # Nearest neighbor distance in primitive lattice
    nn_distance = min(a1_length, a2_length, np.linalg.norm(a1 - a2))
    
    # Next-nearest neighbor distance
    nnn_distance = max(a1_length, a2_length, np.linalg.norm(a1 - a2))
    
    print(f"Primitive cell area: {real_cell_area:.6f}")
    print(f"Conventional cell area: {conventional_cell_area:.6f}")
    print(f"Reciprocal space BZ area: {bz_area:.6f}")
    print(f"Area product: {real_cell_area * bz_area / (4*pi**2):.6f}")  # Should be 1
    print(f"Lattice vector angle: {angle_deg:.1f}°")
    print(f"Aspect ratio (a/b): {a/b:.3f}")
    print(f"Nearest neighbor distance: {nn_distance:.6f}")
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```rust
    use nalgebra::{Vector2, Matrix2x4};
    use std::f64::consts::PI;
    
    // Lattice parameters (user-defined)
    const A: f64 = 1.0;  // conventional lattice constant along x
    const B: f64 = 0.8;  // conventional lattice constant along y
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors (rhombic arrangement)
    fn primitive_vectors(a: f64, b: f64) -> (Vector2<f64>, Vector2<f64>) {
        let a1 = Vector2::new(a/2.0, b/2.0);
        let a2 = Vector2::new(a/2.0, -b/2.0);
        (a1, a2)
    }
    
    // Real space unit cell area (primitive)
    fn real_cell_area(a: f64, b: f64) -> f64 {
        a * b / 2.0
    }
    
    // Lattice vector properties
    fn lattice_vector_properties(a: f64, b: f64) -> (f64, f64, f64, f64) {
        let length = (a*a + b*b).sqrt() / 2.0;
        let dot_product = (a*a - b*b) / 4.0;
        let angle = (dot_product / (length * length)).acos();
        (length, length, dot_product, angle)
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    fn reciprocal_vectors(a: f64, b: f64) -> (Vector2<f64>, Vector2<f64>) {
        let b1 = Vector2::new(2.0*PI/a, 2.0*PI/b);
        let b2 = Vector2::new(2.0*PI/a, -2.0*PI/b);
        (b1, b2)
    }
    
    // Brillouin zone area
    fn bz_area(a: f64, b: f64) -> f64 {
        8.0 * PI * PI / (a * b)
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Fractional coordinates
    const GAMMA_FRAC: Vector2<f64> = Vector2::new(0.0, 0.0);
    const X_FRAC: Vector2<f64> = Vector2::new(0.5, 0.0);
    const Y_FRAC: Vector2<f64> = Vector2::new(0.0, 0.5);
    const M_FRAC: Vector2<f64> = Vector2::new(0.5, 0.5);
    
    // Cartesian coordinates
    fn high_symmetry_points_cart(a: f64, b: f64) -> (Vector2<f64>, Vector2<f64>, Vector2<f64>, Vector2<f64>) {
        let (b1, b2) = reciprocal_vectors(a, b);
        let gamma = Vector2::new(0.0, 0.0);
        let x = 0.5 * b1;
        let y = 0.5 * b2;
        let m = 0.5 * (b1 + b2);
        (gamma, x, y, m)
    }
    
    // ===== BRILLOUIN ZONE VERTICES =====
    
    fn bz_vertices(a: f64, b: f64) -> Matrix2x4<f64> {
        let (b1, b2) = reciprocal_vectors(a, b);
        Matrix2x4::from_columns(&[
            0.5 * (b1 + b2),   // M point
            0.5 * (b1 - b2),
            -0.5 * (b1 + b2),  // -M point
            0.5 * (-b1 + b2)
        ])
    }
    
    // ===== DISTANCES =====
    
    fn nearest_neighbor_distance(a: f64, b: f64) -> f64 {
        let (a1, a2) = primitive_vectors(a, b);
        let d1 = a1.norm();
        let d2 = a2.norm();
        let d3 = (a1 - a2).norm();
        d1.min(d2).min(d3)
    }
    
    fn next_nearest_neighbor_distance(a: f64, b: f64) -> f64 {
        let (a1, a2) = primitive_vectors(a, b);
        let d1 = a1.norm();
        let d2 = a2.norm();
        let d3 = (a1 - a2).norm();
        d1.max(d2).max(d3)
    }
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```cpp
    #include <array>
    #include <cmath>
    #include <iostream>
    #include <algorithm>
    
    // Lattice parameters (user-defined)
    constexpr double A = 1.0;  // conventional lattice constant along x
    constexpr double B = 0.8;  // conventional lattice constant along y
    constexpr double PI = 3.14159265358979323846;
    
    // 2D vector structure
    struct Vector2D {
        double x, y;
        
        Vector2D(double x = 0, double y = 0) : x(x), y(y) {}
        
        Vector2D operator+(const Vector2D& other) const {
            return {x + other.x, y + other.y};
        }
        
        Vector2D operator-(const Vector2D& other) const {
            return {x - other.x, y - other.y};
        }
        
        Vector2D operator*(double scalar) const {
            return {x * scalar, y * scalar};
        }
        
        double dot(const Vector2D& other) const {
            return x * other.x + y * other.y;
        }
        
        double cross(const Vector2D& other) const {
            return x * other.y - y * other.x;
        }
        
        double norm() const {
            return std::sqrt(x*x + y*y);
        }
    };
    
    // ===== REAL SPACE LATTICE =====
    
    std::pair<Vector2D, Vector2D> primitive_vectors(double a, double b) {
        Vector2D a1(a/2.0, b/2.0);
        Vector2D a2(a/2.0, -b/2.0);
        return {a1, a2};
    }
    
    double real_cell_area(double a, double b) {
        return a * b / 2.0;
    }
    
    std::tuple<double, double, double, double> lattice_vector_properties(double a, double b) {
        double length = std::sqrt(a*a + b*b) / 2.0;
        double dot_product = (a*a - b*b) / 4.0;
        double angle = std::acos(dot_product / (length * length));
        return {length, length, dot_product, angle};
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    std::pair<Vector2D, Vector2D> reciprocal_vectors(double a, double b) {
        Vector2D b1(2.0*PI/a, 2.0*PI/b);
        Vector2D b2(2.0*PI/a, -2.0*PI/b);
        return {b1, b2};
    }
    
    double bz_area(double a, double b) {
        return 8.0 * PI * PI / (a * b);
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    struct HighSymmetryPoints {
        Vector2D gamma, x, y, m;
    };
    
    HighSymmetryPoints high_symmetry_points_cart(double a, double b) {
        auto [b1, b2] = reciprocal_vectors(a, b);
        return {
            Vector2D(0.0, 0.0),    // Gamma
            b1 * 0.5,              // X
            b2 * 0.5,              // Y
            (b1 + b2) * 0.5        // M
        };
    }
    
    // ===== DISTANCES =====
    
    double nearest_neighbor_distance(double a, double b) {
        auto [a1, a2] = primitive_vectors(a, b);
        double d1 = a1.norm();
        double d2 = a2.norm();
        double d3 = (a1 - a2).norm();
        return std::min({d1, d2, d3});
    }
    
    int main() {
        auto [a1, a2] = primitive_vectors(A, B);
        auto [length1, length2, dot_prod, angle] = lattice_vector_properties(A, B);
        
        std::cout << "Primitive cell area: " << real_cell_area(A, B) << std::endl;
        std::cout << "Conventional cell area: " << A * B << std::endl;
        std::cout << "Brillouin zone area: " << bz_area(A, B) << std::endl;
        std::cout << "Lattice vector angle: " << angle * 180.0 / PI << "°" << std::endl;
        std::cout << "Nearest neighbor distance: " << nearest_neighbor_distance(A, B) << std::endl;
        
        return 0;
    }
    ```
  </Tabs.Tab>
</Tabs>

## Physical Applications

The rhombic lattice appears in various physical systems and materials:

- **Layered Perovskites**: Many distorted perovskite structures
- **Metal Surfaces**: Reconstructed (110) surfaces of face-centered cubic metals
- **Molecular Crystals**: Organic crystals with centered rectangular packing
- **Magnetic Materials**: Frustrated antiferromagnetic systems
- **Optical Lattices**: Cold atom experiments with rhombic potential arrays
- **Photonic Crystals**: Rhombic arrays of scatterers
- **Surface Reconstructions**: Silicon and compound semiconductor surfaces
- **Liquid Crystal Phases**: Certain 2D ordering in smectic phases

## Relationship to Other Lattices

The rhombic lattice serves as an important bridge between different lattice types:

- **Special Case of Oblique**: When the oblique lattice has equal-length vectors
- **Transition to Square**: When $a = b$, the rhombic lattice becomes square
- **Transition to Rectangular**: In the limit of certain parameter ratios
- **Centered vs Primitive**: Demonstrates the difference between conventional and primitive cells

## Key Properties Summary

- **Centered rectangular symmetry** with 2mm point group
- **Rhombic primitive cell** with equal-length vectors at oblique angles
- **Four-fold coordination** with anisotropic nearest-neighbor distances
- **Complex Brillouin zone** with rhombic shape in reciprocal space
- **Variable aspect ratio** controlled by the $a/b$ parameter
- **Rich high-symmetry structure** with multiple critical points
- **Intermediate complexity** between simple and oblique lattices
- **Important for materials science** in understanding phase transitions and distortions

<Callout type="info">
The rhombic lattice is sometimes called the "centered rectangular" lattice in crystallography, emphasizing its relationship to the rectangular lattice with additional centering points. This lattice type is crucial for understanding many real crystal structures and their electronic properties.
</Callout>
