import { 
    LatticeVisualization2D, 
    ReciprocalLatticeVisualization2D, 
    WignerSeitzCell2D,
    HighSymmetryVisualization2D,
} from '../../../../src/components';

import { Callout, Tabs } from 'nextra/components';

# Square Lattice

The **square lattice** is one of the five fundamental two-dimensional Bravais lattices, characterized by its four-fold rotational symmetry and orthogonal lattice vectors of equal length. This lattice type is ubiquitous in crystallography and condensed matter physics, appearing in many important materials and theoretical models.

## Quick Reference

### Basic Properties

| Property | Value |
|----------|-------|
| **Lattice System** | Tetragonal |
| **Point Group** | 4mm |
| **Coordination Number** | 4 |
| **Primitive Vectors** | Equal length, 90° angle |
| **Unit Cell Area** | $a^2$ |
| **Lattice Type** | Primitive (P) |
| **Packing Density** | π/4 ≈ 0.785 |

### High-Symmetry Points

| Point | Position | Description |
|-------|----------|-------------|
| **Γ** | $(0, 0)$ | Zone center |
| **X** | $\frac{\pi}{a}(1, 0)$ | Edge midpoint |
| **Y** | $\frac{\pi}{a}(0, 1)$ | Edge midpoint |
| **M** | $\frac{\pi}{a}(1, 1)$ | Zone corner |

## Visual Representation

### Real Space Lattice

<LatticeVisualization2D
    latticeType="square"
    a={1}
    shells={2}
    showUnitCell={true}
    showLatticeVectors={true}
/>

**Figure 1:** Square lattice in real space showing lattice points (blue dots), primitive vectors **a₁** and **a₂** (arrows), and the primitive unit cell (dashed square). The lattice exhibits four-fold rotational symmetry with nearest neighbors forming a square coordination.

### Reciprocal Space Lattice

<LatticeVisualization2D
    latticeType="square"
    a={1}
    shells={1}
    showUnitCell={true}
    showLatticeVectors={true}
    is_reciprocal={true}
/>

**Figure 2:** Square reciprocal lattice showing reciprocal lattice points, primitive vectors **b₁** and **b₂**, and the first Brillouin zone (dashed square). The reciprocal lattice maintains the square symmetry with the same orientation.

### Brillouin Zone and High-Symmetry Points

<HighSymmetryVisualization2D
    latticeType="square"
    a={1}
    shells={1}
    showUnitCell={true}
/>

**Figure 3:** First Brillouin zone of the square lattice showing high-symmetry points and paths. The Γ point is at the zone center, X and Y points are at the midpoints of the square edges, and M is at the square corner.

## Mathematical Description

### Real Space

The square lattice is defined by two primitive vectors of equal length with a 90° angle:

$$\mathbf{a}_1 = a \hat{\mathbf{x}}, \quad \mathbf{a}_2 = a \hat{\mathbf{y}}$$

where $a$ is the lattice parameter and the vectors satisfy:

$$|\mathbf{a}_1| = |\mathbf{a}_2| = a, \quad \mathbf{a}_1 \cdot \mathbf{a}_2 = 0$$

The primitive unit cell area is:

$$A = |\mathbf{a}_1 \times \mathbf{a}_2| = a^2$$

### Reciprocal Space

The reciprocal lattice vectors $\mathbf{b}_1$ and $\mathbf{b}_2$ satisfy $\mathbf{a}_i \cdot \mathbf{b}_j = 2\pi \delta_{ij}$:

$$\mathbf{b}_1 = \frac{2\pi}{a}\hat{\mathbf{x}}, \quad \mathbf{b}_2 = \frac{2\pi}{a}\hat{\mathbf{y}}$$

The reciprocal lattice primitive cell area is:

$$A^* = |\mathbf{b}_1 \times \mathbf{b}_2| = \frac{4\pi^2}{a^2}$$

## Real vs Reciprocal Space Comparison

| Property | Real Space | Reciprocal Space |
|----------|------------|------------------|
| **Lattice Type** | Square | Square |
| **Primitive Vectors** | $\|\mathbf{a}\| = a$, angle = 90° | $\|\mathbf{b}\| = \frac{2\pi}{a}$, angle = 90° |
| **Unit Cell Shape** | Square | Square |
| **Unit Cell Area** | $a^2$ | $\frac{4\pi^2}{a^2}$ |
| **Symmetry** | 4-fold rotational | 4-fold rotational |
| **Coordination** | 4 nearest neighbors | 4 nearest neighbors |

## Lattice Data Reference

Essential lattice parameters and coordinates for square lattice calculations:

<Tabs items={['Python', 'Rust', 'C++']}>
  <Tabs.Tab>
    ```python
    import numpy as np
    from math import sqrt, pi
    
    # Lattice parameter (user-defined)
    a = 1.0  # lattice constant
    
    # ===== REAL SPACE LATTICE =====
    
    # Primitive basis vectors (in units of a)
    a1_normalized = np.array([1.0, 0.0])
    a2_normalized = np.array([0.0, 1.0])
    
    # Actual primitive vectors
    a1 = a * a1_normalized
    a2 = a * a2_normalized
    
    # Real space unit cell area
    real_cell_area = a**2
    
    # ===== RECIPROCAL SPACE LATTICE =====
    
    # Reciprocal basis vectors
    b1 = (2*pi/a) * np.array([1.0, 0.0])
    b2 = (2*pi/a) * np.array([0.0, 1.0])
    
    # Brillouin zone area
    bz_area = 4*pi**2 / a**2
    
    # ===== HIGH SYMMETRY POINTS =====
    
    # Fractional coordinates (in units of reciprocal lattice vectors)
    gamma_frac = np.array([0.0, 0.0])
    x_frac = np.array([0.5, 0.0])
    y_frac = np.array([0.0, 0.5])
    m_frac = np.array([0.5, 0.5])
    
    # Cartesian coordinates (in units of 2π/a)
    gamma_cart = np.array([0.0, 0.0])
    x_cart = (pi/a) * np.array([1.0, 0.0])
    y_cart = (pi/a) * np.array([0.0, 1.0])
    m_cart = (pi/a) * np.array([1.0, 1.0])
    
    # ===== BRILLOUIN ZONE VERTICES =====
    
    # First BZ vertices (square corners)
    bz_vertices = (pi/a) * np.array([
        [1.0, 1.0],    # M
        [-1.0, 1.0],   # 
        [-1.0, -1.0],  # -M
        [1.0, -1.0]    # 
    ])
    
    # ===== WIGNER-SEITZ CELL =====
    
    # Real space Wigner-Seitz cell area (same as primitive cell)
    ws_cell_area = real_cell_area
    
    # Nearest neighbor distance
    nn_distance = a
    
    # Next-nearest neighbor distance (diagonal)
    nnn_distance = a * sqrt(2)
    
    print(f"Real space cell area: {real_cell_area:.6f} * a²")
    print(f"Reciprocal space BZ area: {bz_area:.6f} * (2π/a)²")
    print(f"Area product: {real_cell_area * bz_area / (4*pi**2):.6f}")  # Should be 1
    print(f"Nearest neighbor distance: {nn_distance:.6f} * a")
    print(f"Next-nearest neighbor distance: {nnn_distance:.6f} * a")
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```rust
    use nalgebra::{Vector2, Matrix2x4};
    use std::f64::consts::PI;
    
    // Lattice parameter (user-defined)
    const A: f64 = 1.0;  // lattice constant
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors (in units of a)
    const A1_NORMALIZED: Vector2<f64> = Vector2::new(1.0, 0.0);
    const A2_NORMALIZED: Vector2<f64> = Vector2::new(0.0, 1.0);
    
    // Actual primitive vectors
    fn primitive_vectors(a: f64) -> (Vector2<f64>, Vector2<f64>) {
        (Vector2::new(a, 0.0), Vector2::new(0.0, a))
    }
    
    // Real space unit cell area
    fn real_cell_area(a: f64) -> f64 {
        a.powi(2)
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    fn reciprocal_vectors(a: f64) -> (Vector2<f64>, Vector2<f64>) {
        let factor = 2.0 * PI / a;
        let b1 = Vector2::new(factor, 0.0);
        let b2 = Vector2::new(0.0, factor);
        (b1, b2)
    }
    
    // Brillouin zone area
    fn bz_area(a: f64) -> f64 {
        4.0 * PI.powi(2) / a.powi(2)
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Fractional coordinates
    const GAMMA_FRAC: Vector2<f64> = Vector2::new(0.0, 0.0);
    const X_FRAC: Vector2<f64> = Vector2::new(0.5, 0.0);
    const Y_FRAC: Vector2<f64> = Vector2::new(0.0, 0.5);
    const M_FRAC: Vector2<f64> = Vector2::new(0.5, 0.5);
    
    // Cartesian coordinates
    fn high_symmetry_points_cart(a: f64) -> (Vector2<f64>, Vector2<f64>, Vector2<f64>, Vector2<f64>) {
        let factor = PI / a;
        let gamma = Vector2::new(0.0, 0.0);
        let x = Vector2::new(factor, 0.0);
        let y = Vector2::new(0.0, factor);
        let m = Vector2::new(factor, factor);
        (gamma, x, y, m)
    }
    
    // ===== BRILLOUIN ZONE VERTICES =====
    
    fn bz_vertices(a: f64) -> Matrix2x4<f64> {
        let factor = PI / a;
        Matrix2x4::from_columns(&[
            Vector2::new(factor, factor),
            Vector2::new(-factor, factor),
            Vector2::new(-factor, -factor),
            Vector2::new(factor, -factor),
        ])
    }
    
    // ===== DISTANCES =====
    
    fn nearest_neighbor_distance(a: f64) -> f64 {
        a
    }
    
    fn next_nearest_neighbor_distance(a: f64) -> f64 {
        a * 2.0_f64.sqrt()
    }
    
    // ===== AREAS =====
    
    fn ws_cell_area(a: f64) -> f64 {
        real_cell_area(a)  // Same as primitive cell for square lattice
    }
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```cpp
    #include <array>
    #include <cmath>
    #include <iostream>
    
    // Lattice parameter (user-defined)
    const double A = 1.0;  // lattice constant
    const double PI = M_PI;
    const double SQRT2 = std::sqrt(2.0);
    
    struct Point2D {
        double x, y;
        Point2D(double x = 0, double y = 0) : x(x), y(y) {}
        Point2D operator*(double scalar) const {
            return Point2D(x * scalar, y * scalar);
        }
    };
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors (normalized)
    const Point2D A1_NORMALIZED{1.0, 0.0};
    const Point2D A2_NORMALIZED{0.0, 1.0};
    
    // Actual primitive vectors
    std::pair<Point2D, Point2D> primitive_vectors(double a) {
        return {Point2D{a, 0.0}, Point2D{0.0, a}};
    }
    
    // Real space unit cell area
    double real_cell_area(double a) {
        return a * a;
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    std::pair<Point2D, Point2D> reciprocal_vectors(double a) {
        double factor = 2.0 * PI / a;
        Point2D b1{factor, 0.0};
        Point2D b2{0.0, factor};
        return {b1, b2};
    }
    
    // Brillouin zone area
    double bz_area(double a) {
        return 4.0 * PI * PI / (a * a);
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Fractional coordinates
    const Point2D GAMMA_FRAC{0.0, 0.0};
    const Point2D X_FRAC{0.5, 0.0};
    const Point2D Y_FRAC{0.0, 0.5};
    const Point2D M_FRAC{0.5, 0.5};
    
    // Cartesian coordinates
    struct HighSymmetryPoints {
        Point2D gamma, x, y, m;
    };
    
    HighSymmetryPoints high_symmetry_points_cart(double a) {
        double factor = PI / a;
        return {
            {0.0, 0.0},        // Gamma
            {factor, 0.0},     // X
            {0.0, factor},     // Y
            {factor, factor}   // M
        };
    }
    
    // ===== BRILLOUIN ZONE VERTICES =====
    
    std::array<Point2D, 4> bz_vertices(double a) {
        double factor = PI / a;
        return {{
            {factor, factor},
            {-factor, factor},
            {-factor, -factor},
            {factor, -factor}
        }};
    }
    
    // ===== DISTANCES =====
    
    double nearest_neighbor_distance(double a) {
        return a;
    }
    
    double next_nearest_neighbor_distance(double a) {
        return a * SQRT2;
    }
    
    // ===== AREAS =====
    
    double ws_cell_area(double a) {
        return real_cell_area(a);  // Same as primitive cell
    }
    
    // Example usage
    void print_lattice_info(double a) {
        auto areas = std::make_pair(real_cell_area(a), bz_area(a));
        std::cout << "Real space cell area: " << areas.first << " * a²\n";
        std::cout << "Reciprocal space BZ area: " << areas.second << " * (2π/a)²\n";
        std::cout << "Area product: " << (areas.first * areas.second) / (4 * PI * PI) << "\n";
        std::cout << "Nearest neighbor distance: " << nearest_neighbor_distance(a) << " * a\n";
        std::cout << "Next-nearest neighbor distance: " << next_nearest_neighbor_distance(a) << " * a\n";
    }
    ```
  </Tabs.Tab>
</Tabs>

## Physical Applications

The square lattice appears in numerous physical systems:

- **Simple Cubic Crystals**: (001) surfaces of simple cubic crystals
- **Layered Perovskites**: Many 2D perovskite materials
- **Square Lattice Antiferromagnets**: Cu-based compounds like La₂CuO₄
- **Optical Lattices**: Cold atom experiments with square lattice potentials
- **Photonic Crystals**: Square arrays of holes or rods
- **Electronic Devices**: Square pixel arrays in displays and sensors
- **Ising Model**: Theoretical studies of phase transitions

## Key Properties Summary

- **Four-fold rotational symmetry** with C₄ rotation axis
- **Simple cubic coordination** with four nearest neighbors
- **Isotropic nearest-neighbor interactions** along perpendicular directions
- **Simple band structure** with separable dispersion relations
- **Square Brillouin zone** with same orientation as real lattice
- **High symmetry paths** Γ-X-M-Γ commonly used in band structure plots
- **Perfect nesting** of Fermi surface at half-filling for simple tight-binding model
- **Van Hove singularities** at X and Y points for nearest-neighbor hopping
