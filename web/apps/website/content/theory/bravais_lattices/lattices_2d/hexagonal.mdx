import { 
    LatticeVisualization2D, 
    ReciprocalLatticeVisualization2D, 
    WignerSeitzCell2D,
    HighSymmetryVisualization2D,
} from '../../../../src/components';

import { Callout, Tabs } from 'nextra/components';

# Hexagonal Lattice

The **hexagonal lattice** is one of the five fundamental two-dimensional Bravais lattices, characterized by its six-fold rotational symmetry and triangular point arrangement. This lattice type is fundamental in crystallography and solid-state physics, appearing in materials like graphene and hexagonal boron nitride.

## Quick Reference

### Basic Properties

| Property | Value |
|----------|-------|
| **Lattice System** | Hexagonal |
| **Point Group** | 6mm |
| **Coordination Number** | 6 |
| **Primitive Vectors** | Equal length, 120° angle |
| **Unit Cell Area** | $\frac{\sqrt{3}}{2}a^2$ |
| **Lattice Type** | Primitive (P) |
| **Packing Density** | $\frac{\pi}{2\sqrt{3}} \approx 0.907$ |

### High-Symmetry Points

| Point | Position | Description |
|-------|----------|-------------|
| **Γ** | $(0, 0)$ | Zone center |
| **M** | $\frac{2\pi}{a}(\frac{1}{2}, \frac{1}{2\sqrt{3}})$ | Edge midpoint |
| **K** | $\frac{2\pi}{a}(\frac{2}{3}, \frac{2}{3\sqrt{3}})$ | Zone vertex |
| **K'** | $\frac{2\pi}{a}(\frac{2}{3}, -\frac{2}{3\sqrt{3}})$ | Zone vertex |

## Visual Representation

### Real Space Lattice

<LatticeVisualization2D
    latticeType="hexagonal"
    a={1}
    shells={2}
    showUnitCell={true}
    showLatticeVectors={true}
/>

**Figure 1:** Hexagonal lattice in real space showing lattice points (blue dots), primitive vectors **a₁** and **a₂** (arrows), and the primitive unit cell (dashed parallelogram). The lattice exhibits six-fold rotational symmetry with nearest neighbors forming equilateral triangles.

### Reciprocal Space Lattice

<LatticeVisualization2D
    latticeType="hexagonal"
    a={1}
    shells={1}
    showUnitCell={true}
    showLatticeVectors={true}
    is_reciprocal={true}
/>

**Figure 2:** Hexagonal reciprocal lattice showing reciprocal lattice points, primitive vectors **b₁** and **b₂**, and the first Brillouin zone (dashed hexagon). The reciprocal lattice also exhibits hexagonal symmetry.

### Brillouin Zone and High-Symmetry Points

<HighSymmetryVisualization2D
    latticeType="hexagonal"
    a={1}
    shells={1}
    showUnitCell={true}
/>

**Figure 3:** First Brillouin zone of the hexagonal lattice showing high-symmetry points and paths. The Γ point is at the zone center, M points are at the midpoints of the hexagon edges, and K points are at the hexagon vertices.

## Mathematical Description

### Real Space

The hexagonal lattice is defined by two primitive vectors of equal length with a 120° angle:

$$\mathbf{a}_1 = a \hat{\mathbf{x}}, \quad \mathbf{a}_2 = a \left(-\frac{1}{2}\hat{\mathbf{x}} + \frac{\sqrt{3}}{2}\hat{\mathbf{y}}\right)$$

where $a$ is the lattice parameter and the vectors satisfy:

$$|\mathbf{a}_1| = |\mathbf{a}_2| = a, \quad \mathbf{a}_1 \cdot \mathbf{a}_2 = -\frac{a^2}{2}$$

The primitive unit cell area is:

$$A = |\mathbf{a}_1 \times \mathbf{a}_2| = \frac{\sqrt{3}}{2}a^2$$

### Reciprocal Space

The reciprocal lattice vectors $\mathbf{b}_1$ and $\mathbf{b}_2$ satisfy $\mathbf{a}_i \cdot \mathbf{b}_j = 2\pi \delta_{ij}$:

$$\mathbf{b}_1 = \frac{2\pi}{a}\left(\hat{\mathbf{x}} + \frac{1}{\sqrt{3}}\hat{\mathbf{y}}\right), \quad \mathbf{b}_2 = \frac{2\pi}{a}\frac{2}{\sqrt{3}}\hat{\mathbf{y}}$$

The reciprocal lattice primitive cell area is:

$$A^* = |\mathbf{b}_1 \times \mathbf{b}_2| = \frac{8\pi^2}{\sqrt{3}a^2}$$

## Real vs Reciprocal Space Comparison

| Property | Real Space | Reciprocal Space |
|----------|------------|------------------|
| **Lattice Type** | Hexagonal | Hexagonal |
| **Primitive Vectors** | $\|\mathbf{a}\| = a$, angle = 120° | $\|\mathbf{b}\| = \frac{4\pi}{\sqrt{3}a}$, angle = 120° |
| **Unit Cell Shape** | Parallelogram | Hexagon (1st BZ) |
| **Unit Cell Area** | $\frac{\sqrt{3}}{2}a^2$ | $\frac{8\pi^2}{\sqrt{3}a^2}$ |
| **Symmetry** | 6-fold rotational | 6-fold rotational |
| **Coordination** | 6 nearest neighbors | 6 nearest neighbors |

## Lattice Data Reference

Essential lattice parameters and coordinates for hexagonal lattice calculations:

<Tabs items={['Python', 'Rust', 'C++']}>
  <Tabs.Tab>
    ```python
    import numpy as np
    from math import sqrt, pi
    
    # Lattice parameter (user-defined)
    a = 1.0  # lattice constant
    
    # ===== REAL SPACE LATTICE =====
    
    # Primitive basis vectors (in units of a)
    a1_normalized = np.array([1.0, 0.0])
    a2_normalized = np.array([-0.5, sqrt(3)/2])
    
    # Actual primitive vectors
    a1 = a * a1_normalized
    a2 = a * a2_normalized
    
    # Real space unit cell area
    real_cell_area = sqrt(3)/2 * a**2  # ≈ 0.866 * a²
    
    # ===== RECIPROCAL SPACE LATTICE =====
    
    # Reciprocal basis vectors
    b1 = (2*pi/a) * np.array([1.0, 1/sqrt(3)])
    b2 = (2*pi/a) * np.array([0.0, 2/sqrt(3)])
    
    # Brillouin zone area
    bz_area = 8*pi**2 / (sqrt(3) * a**2)
    
    # ===== HIGH SYMMETRY POINTS =====
    
    # Fractional coordinates (in units of reciprocal lattice vectors)
    gamma_frac = np.array([0.0, 0.0])
    m_frac = np.array([0.5, 0.0])
    k_frac = np.array([2/3, 1/3])
    k_prime_frac = np.array([2/3, -1/3])
    
    # Cartesian coordinates (in units of 2π/a)
    gamma_cart = np.array([0.0, 0.0])
    m_cart = (2*pi/a) * np.array([0.5, 1/(2*sqrt(3))])
    k_cart = (2*pi/a) * np.array([2/3, 2/(3*sqrt(3))])
    k_prime_cart = (2*pi/a) * np.array([2/3, -2/(3*sqrt(3))])
    
    # ===== BRILLOUIN ZONE VERTICES =====
    
    # First BZ vertices (hexagon corners)
    bz_vertices = (2*pi/a) * np.array([
        [2/3, 2/(3*sqrt(3))],    # K
        [1/3, 2/(3*sqrt(3))],    # 
        [-1/3, 2/(3*sqrt(3))],   # K'
        [-2/3, -2/(3*sqrt(3))],  # -K
        [-1/3, -2/(3*sqrt(3))],  # 
        [1/3, -2/(3*sqrt(3))]    # -K'
    ])
    
    # ===== WIGNER-SEITZ CELL =====
    
    # Real space Wigner-Seitz cell area (same as primitive cell)
    ws_cell_area = real_cell_area
    
    print(f"Real space cell area: {real_cell_area:.6f} * a²")
    print(f"Reciprocal space BZ area: {bz_area:.6f} * (2π/a)²")
    print(f"Area product: {real_cell_area * bz_area / (4*pi**2):.6f}")  # Should be 1
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```rust
    use nalgebra::{Vector2, Matrix2x6};
    use std::f64::consts::PI;
    
    // Lattice parameter (user-defined)
    const A: f64 = 1.0;  // lattice constant
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors (in units of a)
    const A1_NORMALIZED: Vector2<f64> = Vector2::new(1.0, 0.0);
    const A2_NORMALIZED: Vector2<f64> = Vector2::new(-0.5, 0.5 * 1.7320508075688772);  // sqrt(3)/2
    
    // Actual primitive vectors
    fn primitive_vectors(a: f64) -> (Vector2<f64>, Vector2<f64>) {
        (a * A1_NORMALIZED, a * A2_NORMALIZED)
    }
    
    // Real space unit cell area
    fn real_cell_area(a: f64) -> f64 {
        0.5 * 3.0_f64.sqrt() * a.powi(2)  // sqrt(3)/2 * a²
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    fn reciprocal_vectors(a: f64) -> (Vector2<f64>, Vector2<f64>) {
        let factor = 2.0 * PI / a;
        let b1 = Vector2::new(factor, factor / 3.0_f64.sqrt());
        let b2 = Vector2::new(0.0, 2.0 * factor / 3.0_f64.sqrt());
        (b1, b2)
    }
    
    // Brillouin zone area
    fn bz_area(a: f64) -> f64 {
        8.0 * PI.powi(2) / (3.0_f64.sqrt() * a.powi(2))
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Fractional coordinates
    const GAMMA_FRAC: Vector2<f64> = Vector2::new(0.0, 0.0);
    const M_FRAC: Vector2<f64> = Vector2::new(0.5, 0.0);
    const K_FRAC: Vector2<f64> = Vector2::new(2.0/3.0, 1.0/3.0);
    const K_PRIME_FRAC: Vector2<f64> = Vector2::new(2.0/3.0, -1.0/3.0);
    
    // Cartesian coordinates
    fn high_symmetry_points_cart(a: f64) -> (Vector2<f64>, Vector2<f64>, Vector2<f64>, Vector2<f64>) {
        let factor = 2.0 * PI / a;
        let gamma = Vector2::new(0.0, 0.0);
        let m = factor * Vector2::new(0.5, 1.0 / (2.0 * 3.0_f64.sqrt()));
        let k = factor * Vector2::new(2.0/3.0, 2.0 / (3.0 * 3.0_f64.sqrt()));
        let k_prime = factor * Vector2::new(2.0/3.0, -2.0 / (3.0 * 3.0_f64.sqrt()));
        (gamma, m, k, k_prime)
    }
    
    // ===== BRILLOUIN ZONE VERTICES =====
    
    fn bz_vertices(a: f64) -> Matrix2x6<f64> {
        let factor = 2.0 * PI / a;
        let sqrt3_inv = 1.0 / 3.0_f64.sqrt();
        
        Matrix2x6::from_columns(&[
            Vector2::new(2.0/3.0, 2.0/3.0 * sqrt3_inv),
            Vector2::new(1.0/3.0, 2.0/3.0 * sqrt3_inv),
            Vector2::new(-1.0/3.0, 2.0/3.0 * sqrt3_inv),
            Vector2::new(-2.0/3.0, -2.0/3.0 * sqrt3_inv),
            Vector2::new(-1.0/3.0, -2.0/3.0 * sqrt3_inv),
            Vector2::new(1.0/3.0, -2.0/3.0 * sqrt3_inv),
        ]) * factor
    }
    
    // ===== AREAS =====
    
    fn ws_cell_area(a: f64) -> f64 {
        real_cell_area(a)  // Same as primitive cell for hexagonal lattice
    }
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```cpp
    #include <array>
    #include <cmath>
    #include <iostream>
    
    // Lattice parameter (user-defined)
    const double A = 1.0;  // lattice constant
    const double PI = M_PI;
    const double SQRT3 = std::sqrt(3.0);
    
    struct Point2D {
        double x, y;
        Point2D(double x = 0, double y = 0) : x(x), y(y) {}
        Point2D operator*(double scalar) const {
            return Point2D(x * scalar, y * scalar);
        }
    };
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors (normalized)
    const Point2D A1_NORMALIZED{1.0, 0.0};
    const Point2D A2_NORMALIZED{-0.5, SQRT3/2.0};
    
    // Actual primitive vectors
    std::pair<Point2D, Point2D> primitive_vectors(double a) {
        return {A1_NORMALIZED * a, A2_NORMALIZED * a};
    }
    
    // Real space unit cell area
    double real_cell_area(double a) {
        return SQRT3/2.0 * a * a;
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    std::pair<Point2D, Point2D> reciprocal_vectors(double a) {
        double factor = 2.0 * PI / a;
        Point2D b1{factor, factor / SQRT3};
        Point2D b2{0.0, 2.0 * factor / SQRT3};
        return {b1, b2};
    }
    
    // Brillouin zone area
    double bz_area(double a) {
        return 8.0 * PI * PI / (SQRT3 * a * a);
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Fractional coordinates
    const Point2D GAMMA_FRAC{0.0, 0.0};
    const Point2D M_FRAC{0.5, 0.0};
    const Point2D K_FRAC{2.0/3.0, 1.0/3.0};
    const Point2D K_PRIME_FRAC{2.0/3.0, -1.0/3.0};
    
    // Cartesian coordinates
    struct HighSymmetryPoints {
        Point2D gamma, m, k, k_prime;
    };
    
    HighSymmetryPoints high_symmetry_points_cart(double a) {
        double factor = 2.0 * PI / a;
        return {
            {0.0, 0.0},  // Gamma
            {factor * 0.5, factor / (2.0 * SQRT3)},  // M
            {factor * 2.0/3.0, factor * 2.0 / (3.0 * SQRT3)},  // K
            {factor * 2.0/3.0, factor * (-2.0) / (3.0 * SQRT3)}  // K'
        };
    }
    
    // ===== BRILLOUIN ZONE VERTICES =====
    
    std::array<Point2D, 6> bz_vertices(double a) {
        double factor = 2.0 * PI / a;
        double sqrt3_inv = 1.0 / SQRT3;
        
        return {{
            {factor * 2.0/3.0, factor * 2.0/3.0 * sqrt3_inv},
            {factor * 1.0/3.0, factor * 2.0/3.0 * sqrt3_inv},
            {factor * (-1.0/3.0), factor * 2.0/3.0 * sqrt3_inv},
            {factor * (-2.0/3.0), factor * (-2.0/3.0) * sqrt3_inv},
            {factor * (-1.0/3.0), factor * (-2.0/3.0) * sqrt3_inv},
            {factor * 1.0/3.0, factor * (-2.0/3.0) * sqrt3_inv}
        }};
    }
    
    // ===== AREAS =====
    
    double ws_cell_area(double a) {
        return real_cell_area(a);  // Same as primitive cell
    }
    
    // Example usage
    void print_lattice_info(double a) {
        auto areas = std::make_pair(real_cell_area(a), bz_area(a));
        std::cout << "Real space cell area: " << areas.first << " * a²\n";
        std::cout << "BZ area: " << areas.second << " * (2π/a)²\n";
        std::cout << "Area product: " << (areas.first * areas.second) / (4 * PI * PI) << "\n";
    }
    ```
  </Tabs.Tab>
</Tabs>

## Physical Applications

The hexagonal lattice appears in numerous physical systems:

- **Graphene**: Carbon atoms arranged in a hexagonal lattice
- **Hexagonal Boron Nitride (h-BN)**: Layered material with hexagonal structure
- **Transition Metal Dichalcogenides (TMDs)**: Many 2D semiconductors
- **Crystal Surfaces**: (111) surfaces of FCC crystals
- **Photonic Crystals**: Engineered structures for light manipulation

## Key Properties Summary

- **Six-fold rotational symmetry** with C₆ rotation axis
- **Highest packing density** among 2D lattices (π/2√3 ≈ 0.907)
- **Isotropic nearest-neighbor interactions** due to symmetry
- **Degenerate K and K' points** at Brillouin zone vertices (important for graphene physics)
- **Dual lattice relationship**: Reciprocal lattice is also hexagonal but rotated 30°
