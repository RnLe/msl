import { 
    LatticeVisualization2D, 
    ReciprocalLatticeVisualization2D, 
    WignerSeitzCell2D,
    HighSymmetryVisualization2D,
} from '../../../../src/components';

import { Callout, Tabs } from 'nextra/components';

# Oblique Lattice

The **oblique lattice** is the most general of the five fundamental two-dimensional Bravais lattices, characterized by having no symmetry restrictions on the lattice vectors. With arbitrary lengths and angles, it represents the lowest-symmetry lattice and serves as the parent structure from which all other 2D lattices can be derived through symmetry constraints.

## Quick Reference

### Basic Properties

| Property | Value |
|----------|-------|
| **Lattice System** | Oblique (Triclinic) |
| **Point Group** | 1 |
| **Coordination Number** | Variable (typically 6) |
| **Primitive Vectors** | Arbitrary lengths and angle |
| **Unit Cell Area** | $ab\sin\gamma$ |
| **Lattice Type** | Primitive (P) |
| **Packing Density** | Variable |

### High-Symmetry Points

| Point | Position | Description |
|-------|----------|-------------|
| **Γ** | $(0, 0)$ | Zone center |
| **General** | Various | No special symmetry points |

## Visual Representation

### Real Space Lattice

<LatticeVisualization2D
    latticeType="oblique"
    a={1}
    b={0.8}
    gamma={110}
    shells={2}
    showUnitCell={true}
    showLatticeVectors={true}
/>

**Figure 1:** Oblique lattice in real space showing lattice points (blue dots), primitive vectors **a₁** and **a₂** (arrows), and the primitive unit cell (dashed parallelogram). The lattice has the most general geometry with arbitrary vector lengths a, b and angle γ.

### Reciprocal Space Lattice

<LatticeVisualization2D
    latticeType="oblique"
    a={1}
    b={0.8}
    gamma={110}
    shells={1}
    showUnitCell={true}
    showLatticeVectors={true}
    is_reciprocal={true}
/>

**Figure 2:** Oblique reciprocal lattice showing reciprocal lattice points, primitive vectors **b₁** and **b₂**, and the first Brillouin zone (dashed parallelogram). The reciprocal lattice maintains the oblique character but with transformed parameters.

### Brillouin Zone and High-Symmetry Points

<HighSymmetryVisualization2D
    latticeType="oblique"
    a={1}
    b={0.8}
    gamma={110}
    shells={1}
    showUnitCell={true}
/>

**Figure 3:** First Brillouin zone of the oblique lattice. Due to the low symmetry, there are typically no special high-symmetry points other than the Γ point at the zone center. The Brillouin zone is a general parallelogram.

## Mathematical Description

### Real Space

The oblique lattice is defined by two primitive vectors with arbitrary lengths and angle:

$$\mathbf{a}_1 = a \hat{\mathbf{x}}, \quad \mathbf{a}_2 = b(\cos\gamma \hat{\mathbf{x}} + \sin\gamma \hat{\mathbf{y}})$$

where $a$ and $b$ are the lattice parameters and $\gamma$ is the angle between the vectors. The vectors satisfy:

$$|\mathbf{a}_1| = a, \quad |\mathbf{a}_2| = b, \quad \mathbf{a}_1 \cdot \mathbf{a}_2 = ab\cos\gamma$$

The primitive unit cell area is:

$$A = |\mathbf{a}_1 \times \mathbf{a}_2| = ab\sin\gamma$$

### Reciprocal Space

The reciprocal lattice vectors $\mathbf{b}_1$ and $\mathbf{b}_2$ satisfy $\mathbf{a}_i \cdot \mathbf{b}_j = 2\pi \delta_{ij}$:

$$\mathbf{b}_1 = \frac{2\pi}{a\sin\gamma}(\hat{\mathbf{x}} - \cos\gamma \hat{\mathbf{y}}), \quad \mathbf{b}_2 = \frac{2\pi}{b\sin\gamma}\hat{\mathbf{y}}$$

The reciprocal lattice vectors have lengths:

$$|\mathbf{b}_1| = \frac{2\pi}{a\sin\gamma}, \quad |\mathbf{b}_2| = \frac{2\pi}{b\sin\gamma}$$

and the angle between them is:

$$\cos\gamma^* = -\cos\gamma$$

where $\gamma^* = 180° - \gamma$ is the reciprocal lattice angle.

The reciprocal lattice primitive cell area is:

$$A^* = |\mathbf{b}_1 \times \mathbf{b}_2| = \frac{4\pi^2}{ab\sin\gamma}$$

## Real vs Reciprocal Space Comparison

| Property | Real Space | Reciprocal Space |
|----------|------------|------------------|
| **Lattice Type** | Oblique | Oblique |
| **Vector Lengths** | $a$, $b$ | $\frac{2\pi}{a\sin\gamma}$, $\frac{2\pi}{b\sin\gamma}$ |
| **Angle** | $\gamma$ | $\gamma^* = 180° - \gamma$ |
| **Unit Cell Shape** | General parallelogram | General parallelogram |
| **Unit Cell Area** | $ab\sin\gamma$ | $\frac{4\pi^2}{ab\sin\gamma}$ |
| **Symmetry** | No rotational symmetry | No rotational symmetry |
| **Coordination** | Variable (typically 6) | Variable (typically 6) |

## Lattice Data Reference

Essential lattice parameters and coordinates for oblique lattice calculations:

<Tabs items={['Python', 'Rust', 'C++']}>
  <Tabs.Tab>
    ```python
    import numpy as np
    from math import sqrt, pi, cos, sin, radians, degrees, acos
    
    # Lattice parameters (user-defined)
    a = 1.0      # lattice constant along first vector
    b = 0.8      # lattice constant along second vector
    gamma_deg = 110  # angle between vectors in degrees
    gamma = radians(gamma_deg)  # angle in radians
    
    # ===== REAL SPACE LATTICE =====
    
    # Primitive basis vectors
    a1 = np.array([a, 0.0])
    a2 = np.array([b * cos(gamma), b * sin(gamma)])
    
    # Real space unit cell area
    real_cell_area = abs(np.cross(a1, a2))  # = ab*sin(γ)
    
    # Lattice vector properties
    a1_length = np.linalg.norm(a1)  # = a
    a2_length = np.linalg.norm(a2)  # = b
    dot_product = np.dot(a1, a2)    # = ab*cos(γ)
    angle_check = acos(dot_product / (a1_length * a2_length))  # Should equal γ
    
    # ===== RECIPROCAL SPACE LATTICE =====
    
    # Reciprocal basis vectors
    sin_gamma = sin(gamma)
    cos_gamma = cos(gamma)
    
    b1 = (2*pi / (a * sin_gamma)) * np.array([1.0, -cos_gamma])
    b2 = (2*pi / (b * sin_gamma)) * np.array([0.0, 1.0])
    
    # Alternative calculation using the general formula
    # For 2D: b1 = 2π * (a2_perp) / |a1 × a2|
    a1_perp = np.array([a2[1], -a2[0]])  # Perpendicular to a2
    a2_perp = np.array([-a1[1], a1[0]])  # Perpendicular to a1
    
    b1_alt = 2*pi * a1_perp / real_cell_area
    b2_alt = 2*pi * a2_perp / real_cell_area
    
    # Reciprocal lattice properties
    b1_length = np.linalg.norm(b1)  # = 2π/(a*sin(γ))
    b2_length = np.linalg.norm(b2)  # = 2π/(b*sin(γ))
    b_dot_product = np.dot(b1, b2)
    gamma_star = acos(b_dot_product / (b1_length * b2_length))
    gamma_star_deg = degrees(gamma_star)  # Should be 180° - γ
    
    # Brillouin zone area
    bz_area = abs(np.cross(b1, b2))  # = 4π²/(ab*sin(γ))
    
    # ===== HIGH SYMMETRY POINTS =====
    
    # For oblique lattice, only Gamma point is special
    gamma_point = np.array([0.0, 0.0])
    
    # Edge midpoints (not necessarily high symmetry)
    edge_midpoints = [
        0.5 * b1,           # Midpoint of first edge
        0.5 * b2,           # Midpoint of second edge
        0.5 * (b1 + b2),    # Opposite corner
        0.5 * (b1 - b2)     # Other diagonal
    ]
    
    # ===== GENERAL PROPERTIES =====
    
    # Nearest neighbor vectors
    nn_vectors = [a1, a2, a1-a2, -a1, -a2, a2-a1]
    nn_distances = [np.linalg.norm(v) for v in nn_vectors]
    min_nn_distance = min(nn_distances)
    
    # Unit cell vertices
    cell_vertices = np.array([
        [0, 0],
        a1,
        a1 + a2,
        a2
    ])
    
    # Metric tensor for coordinate transformations
    metric_tensor = np.array([
        [a*a, a*b*cos_gamma],
        [a*b*cos_gamma, b*b]
    ])
    
    # Reciprocal metric tensor
    reciprocal_metric = np.linalg.inv(metric_tensor) * (2*pi)**2
    
    print(f"Real space cell area: {real_cell_area:.6f}")
    print(f"Reciprocal space BZ area: {bz_area:.6f}")
    print(f"Area product: {real_cell_area * bz_area / (4*pi**2):.6f}")  # Should be 1
    print(f"Real space angle γ: {gamma_deg:.1f}°")
    print(f"Reciprocal space angle γ*: {gamma_star_deg:.1f}°")
    print(f"Angle sum: {gamma_deg + gamma_star_deg:.1f}°")  # Should be 180°
    print(f"Minimum nearest neighbor distance: {min_nn_distance:.6f}")
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```rust
    use nalgebra::{Vector2, Matrix2};
    use std::f64::consts::PI;
    
    // Lattice parameters (user-defined)
    const A: f64 = 1.0;        // lattice constant along first vector
    const B: f64 = 0.8;        // lattice constant along second vector
    const GAMMA_DEG: f64 = 110.0;  // angle between vectors in degrees
    
    fn deg_to_rad(deg: f64) -> f64 {
        deg * PI / 180.0
    }
    
    fn rad_to_deg(rad: f64) -> f64 {
        rad * 180.0 / PI
    }
    
    // ===== REAL SPACE LATTICE =====
    
    // Primitive basis vectors
    fn primitive_vectors(a: f64, b: f64, gamma_deg: f64) -> (Vector2<f64>, Vector2<f64>) {
        let gamma = deg_to_rad(gamma_deg);
        let a1 = Vector2::new(a, 0.0);
        let a2 = Vector2::new(b * gamma.cos(), b * gamma.sin());
        (a1, a2)
    }
    
    // Real space unit cell area
    fn real_cell_area(a: f64, b: f64, gamma_deg: f64) -> f64 {
        let gamma = deg_to_rad(gamma_deg);
        a * b * gamma.sin()
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    // Reciprocal basis vectors
    fn reciprocal_vectors(a: f64, b: f64, gamma_deg: f64) -> (Vector2<f64>, Vector2<f64>) {
        let gamma = deg_to_rad(gamma_deg);
        let sin_gamma = gamma.sin();
        let cos_gamma = gamma.cos();
        
        let b1 = (2.0 * PI / (a * sin_gamma)) * Vector2::new(1.0, -cos_gamma);
        let b2 = (2.0 * PI / (b * sin_gamma)) * Vector2::new(0.0, 1.0);
        (b1, b2)
    }
    
    // Brillouin zone area
    fn bz_area(a: f64, b: f64, gamma_deg: f64) -> f64 {
        let gamma = deg_to_rad(gamma_deg);
        4.0 * PI * PI / (a * b * gamma.sin())
    }
    
    // Reciprocal space angle
    fn reciprocal_angle(gamma_deg: f64) -> f64 {
        180.0 - gamma_deg
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    // Only Gamma point is special for oblique lattice
    const GAMMA_POINT: Vector2<f64> = Vector2::new(0.0, 0.0);
    
    // Edge midpoints (not necessarily high symmetry)
    fn edge_midpoints(a: f64, b: f64, gamma_deg: f64) -> [Vector2<f64>; 4] {
        let (b1, b2) = reciprocal_vectors(a, b, gamma_deg);
        [
            b1 * 0.5,
            b2 * 0.5,
            (b1 + b2) * 0.5,
            (b1 - b2) * 0.5
        ]
    }
    
    // ===== DISTANCES =====
    
    fn nearest_neighbor_distances(a: f64, b: f64, gamma_deg: f64) -> Vec<f64> {
        let (a1, a2) = primitive_vectors(a, b, gamma_deg);
        let nn_vectors = [a1, a2, a1 - a2, -a1, -a2, a2 - a1];
        nn_vectors.iter().map(|v| v.norm()).collect()
    }
    
    fn minimum_nn_distance(a: f64, b: f64, gamma_deg: f64) -> f64 {
        nearest_neighbor_distances(a, b, gamma_deg)
            .into_iter()
            .fold(f64::INFINITY, f64::min)
    }
    
    // ===== METRIC TENSOR =====
    
    fn metric_tensor(a: f64, b: f64, gamma_deg: f64) -> Matrix2<f64> {
        let gamma = deg_to_rad(gamma_deg);
        let cos_gamma = gamma.cos();
        
        Matrix2::new(
            a*a, a*b*cos_gamma,
            a*b*cos_gamma, b*b
        )
    }
    
    fn reciprocal_metric_tensor(a: f64, b: f64, gamma_deg: f64) -> Matrix2<f64> {
        let metric = metric_tensor(a, b, gamma_deg);
        metric.try_inverse().unwrap() * (2.0 * PI).powi(2)
    }
    ```
  </Tabs.Tab>
  
  <Tabs.Tab>
    ```cpp
    #include <array>
    #include <cmath>
    #include <iostream>
    #include <vector>
    #include <algorithm>
    
    // Lattice parameters (user-defined)
    constexpr double A = 1.0;        // lattice constant along first vector
    constexpr double B = 0.8;        // lattice constant along second vector
    constexpr double GAMMA_DEG = 110.0;  // angle between vectors in degrees
    constexpr double PI = 3.14159265358979323846;
    
    // 2D vector structure
    struct Vector2D {
        double x, y;
        
        Vector2D(double x = 0, double y = 0) : x(x), y(y) {}
        
        Vector2D operator+(const Vector2D& other) const {
            return {x + other.x, y + other.y};
        }
        
        Vector2D operator-(const Vector2D& other) const {
            return {x - other.x, y - other.y};
        }
        
        Vector2D operator*(double scalar) const {
            return {x * scalar, y * scalar};
        }
        
        Vector2D operator-() const {
            return {-x, -y};
        }
        
        double dot(const Vector2D& other) const {
            return x * other.x + y * other.y;
        }
        
        double cross(const Vector2D& other) const {
            return x * other.y - y * other.x;
        }
        
        double norm() const {
            return std::sqrt(x*x + y*y);
        }
    };
    
    // Helper functions
    constexpr double deg_to_rad(double deg) {
        return deg * PI / 180.0;
    }
    
    constexpr double rad_to_deg(double rad) {
        return rad * 180.0 / PI;
    }
    
    // ===== REAL SPACE LATTICE =====
    
    std::pair<Vector2D, Vector2D> primitive_vectors(double a, double b, double gamma_deg) {
        double gamma = deg_to_rad(gamma_deg);
        Vector2D a1(a, 0.0);
        Vector2D a2(b * std::cos(gamma), b * std::sin(gamma));
        return {a1, a2};
    }
    
    double real_cell_area(double a, double b, double gamma_deg) {
        double gamma = deg_to_rad(gamma_deg);
        return a * b * std::sin(gamma);
    }
    
    // ===== RECIPROCAL SPACE LATTICE =====
    
    std::pair<Vector2D, Vector2D> reciprocal_vectors(double a, double b, double gamma_deg) {
        double gamma = deg_to_rad(gamma_deg);
        double sin_gamma = std::sin(gamma);
        double cos_gamma = std::cos(gamma);
        
        Vector2D b1((2.0 * PI / (a * sin_gamma)), (2.0 * PI / (a * sin_gamma)) * (-cos_gamma));
        Vector2D b2(0.0, 2.0 * PI / (b * sin_gamma));
        return {b1, b2};
    }
    
    double bz_area(double a, double b, double gamma_deg) {
        double gamma = deg_to_rad(gamma_deg);
        return 4.0 * PI * PI / (a * b * std::sin(gamma));
    }
    
    double reciprocal_angle(double gamma_deg) {
        return 180.0 - gamma_deg;
    }
    
    // ===== HIGH SYMMETRY POINTS =====
    
    struct HighSymmetryPoints {
        Vector2D gamma;
        std::array<Vector2D, 4> edge_midpoints;
    };
    
    HighSymmetryPoints high_symmetry_points(double a, double b, double gamma_deg) {
        auto [b1, b2] = reciprocal_vectors(a, b, gamma_deg);
        
        return {
            Vector2D(0.0, 0.0),  // Gamma point
            {{
                b1 * 0.5,           // Edge midpoint 1
                b2 * 0.5,           // Edge midpoint 2
                (b1 + b2) * 0.5,    // Corner
                (b1 - b2) * 0.5     // Other diagonal
            }}
        };
    }
    
    // ===== DISTANCES =====
    
    std::vector<double> nearest_neighbor_distances(double a, double b, double gamma_deg) {
        auto [a1, a2] = primitive_vectors(a, b, gamma_deg);
        std::vector<Vector2D> nn_vectors = {a1, a2, a1 - a2, -a1, -a2, a2 - a1};
        
        std::vector<double> distances;
        for (const auto& v : nn_vectors) {
            distances.push_back(v.norm());
        }
        return distances;
    }
    
    double minimum_nn_distance(double a, double b, double gamma_deg) {
        auto distances = nearest_neighbor_distances(a, b, gamma_deg);
        return *std::min_element(distances.begin(), distances.end());
    }
    
    // ===== METRIC TENSOR =====
    
    struct Matrix2x2 {
        double m11, m12, m21, m22;
        
        Matrix2x2(double m11, double m12, double m21, double m22) 
            : m11(m11), m12(m12), m21(m21), m22(m22) {}
        
        double det() const {
            return m11 * m22 - m12 * m21;
        }
        
        Matrix2x2 inverse() const {
            double d = det();
            return Matrix2x2(m22/d, -m12/d, -m21/d, m11/d);
        }
        
        Matrix2x2 operator*(double scalar) const {
            return Matrix2x2(m11*scalar, m12*scalar, m21*scalar, m22*scalar);
        }
    };
    
    Matrix2x2 metric_tensor(double a, double b, double gamma_deg) {
        double gamma = deg_to_rad(gamma_deg);
        double cos_gamma = std::cos(gamma);
        
        return Matrix2x2(
            a*a, a*b*cos_gamma,
            a*b*cos_gamma, b*b
        );
    }
    
    Matrix2x2 reciprocal_metric_tensor(double a, double b, double gamma_deg) {
        auto metric = metric_tensor(a, b, gamma_deg);
        return metric.inverse() * (2.0 * PI * 2.0 * PI);
    }
    
    // Example usage
    int main() {
        auto [a1, a2] = primitive_vectors(A, B, GAMMA_DEG);
        auto [b1, b2] = reciprocal_vectors(A, B, GAMMA_DEG);
        
        std::cout << "Real space cell area: " << real_cell_area(A, B, GAMMA_DEG) << std::endl;
        std::cout << "Brillouin zone area: " << bz_area(A, B, GAMMA_DEG) << std::endl;
        std::cout << "Real space angle γ: " << GAMMA_DEG << "°" << std::endl;
        std::cout << "Reciprocal space angle γ*: " << reciprocal_angle(GAMMA_DEG) << "°" << std::endl;
        std::cout << "Minimum NN distance: " << minimum_nn_distance(A, B, GAMMA_DEG) << std::endl;
        
        return 0;
    }
    ```
  </Tabs.Tab>
</Tabs>

## Physical Applications

The oblique lattice, while having the lowest symmetry, appears in various physical systems:

- **Triclinic Crystals**: The most general crystal system
- **Molecular Crystals**: Complex organic molecules with no symmetry constraints
- **Liquid Crystal Phases**: Tilted smectic phases
- **Surface Reconstructions**: Complex reconstructed surfaces
- **Strained Materials**: Crystals under non-uniform stress
- **Quasi-2D Materials**: Layered materials with low in-plane symmetry
- **Polymer Films**: Thin films with arbitrary chain orientations
- **Incommensurate Structures**: Modulated crystal structures

## Relationship to Other Lattices

The oblique lattice is the parent of all other 2D lattices through symmetry constraints:

- **→ Rectangular**: When $\gamma = 90°$
- **→ Square**: When $a = b$ and $\gamma = 90°$
- **→ Hexagonal**: When $a = b$ and $\gamma = 120°$
- **→ Rhombic**: When $a = b$ (special case)

## Special Cases and Limits

### High-Symmetry Limits

1. **Rectangular Limit**: $\gamma \to 90°$
   - Recovers rectangular lattice symmetry
   - Develops mirror planes

2. **Rhombic Limit**: $a \to b$
   - Equal vector lengths
   - Enhanced symmetry along angle bisector

3. **Nearly Hexagonal**: $a \approx b$, $\gamma \approx 120°$
   - Approaches hexagonal symmetry
   - Useful for studying distortions

### Extreme Angle Cases

1. **Acute Angles**: $\gamma < 90°$
   - Compressed parallelogram
   - Different coordination patterns

2. **Obtuse Angles**: $\gamma > 90°$
   - Expanded parallelogram
   - Modified nearest-neighbor relationships

## Key Properties Summary

- **Lowest symmetry** among all 2D Bravais lattices
- **Most general geometry** with arbitrary $a$, $b$, and $\gamma$
- **No special high-symmetry points** except Γ in reciprocal space
- **Variable coordination** depending on lattice parameters
- **Parent lattice** for all other 2D lattices through symmetry breaking
- **Complex Brillouin zone** with no inherent symmetries
- **Rich parameter space** for materials design and tuning
- **Foundation for understanding** crystallographic relationships

<Callout type="info">
The oblique lattice represents the most fundamental 2D lattice structure. Understanding its properties is crucial for crystallography, as all other lattices can be viewed as special cases with additional symmetry constraints. Its generality makes it particularly important for studying materials with complex structures or under external perturbations.
</Callout>

<Callout type="warning">
Due to the lack of symmetry, calculations for oblique lattices are generally more complex than for higher-symmetry lattices. Special care must be taken when defining coordinate systems and transformation matrices for oblique lattices.
</Callout>
